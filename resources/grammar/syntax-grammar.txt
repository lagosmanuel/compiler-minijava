%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This file is the specification of the LL(1) context-free-grammar of the
language syntax. To be LL(1) any production must have no left recursion and
must be left factored. 

The grammar follows the extended-BNF notation where:
terminal    is a terminal symbol
<Class>     is a non-terminal symbol, with the first letter in uppercase
e           is the empty string
<X>::=a     is a production, where a is a sequence of terminals and non-terminals
<X>::=a|b   is an abbreviation of <X>::=a and <X>::=b
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

--------------------------------------------------------------------------------
1. Classes, Methods and Attributes
--------------------------------------------------------------------------------

<Start> ::= <ClassList>
<ClassList> ::= <Class> <ClassList> | e
<Class> ::= class idClass <InheritanceOptional> { <MemberList> }
<InheritanceOptional> ::= extends idClass | e

<MemberList> ::= <Member> <MemberList> | e
<Member> ::= <StaticOptional> <MemberType> idMetVar <MemberRest> | <Constructor>
<MemberRest> ::= ; | <FormalArgs> <Block>
<Constructor> ::= public idClass <FormalArgs> <Block>
<StaticOptional> ::= static | e

<MemberType> ::= <Type> | void
<Type> ::= <PrimitiveType> | idClass
<PrimitiveType> ::= boolean | char | int

<FormalArgs> ::= ( <FormalArgsListOptional> )
<FormalArgsListOptional> ::= <FormalArgsList> | e
<FormalArgsList> ::= <FormalArg> <FormalArgsListRest>
<FormalArgsListRest> ::= , <FormalArgsList> | e
<FormalArg> ::= <Type> idMetVar

--------------------------------------------------------------------------------
2. Statements and Blocks
--------------------------------------------------------------------------------

<Block> ::= { <StatementList> }
<StatementList> ::= <Statement> <StatementList> | e
<StatementOptional> ::= <Statement> | e

<Statement> ::= ;
<Statement> ::= <Expression> ; /* Assignment or Call */
<Statement> ::= <LocalVar> ;
<Statement> ::= <Return> ;
<Statement> ::= <Break> ;
<Statement> ::= <If>
<Statement> ::= <While>
<Statement> ::= <Switch>
<Statement> ::= <Block>

<LocalVar> ::= var idMetVar = <CompositeExpression>
<Return> ::= return <ExpressionOptional>
<Break> ::= break

<If> ::= if ( <Expression> ) <Statement> <IfRest>
<IfRest> ::= else <Statement> | e

<While> ::= while ( <Expression> ) <Statement>

<Switch> ::= switch ( <Expression> ) { <SwitchStatementList> }
<SwitchStatementList> ::= <SwitchStatement> <SwitchStatementList> | e
<SwitchStatement> ::= case <PrimitiveLiteral> : <StatementOptional>
<SwitchStatement> ::= default : <Statement>

--------------------------------------------------------------------------------
3. Expressions
--------------------------------------------------------------------------------

<ExpressionOptional> ::= <Expression> | e
<Expression> ::= <CompositeExpression> <ExpressionRest>
<ExpressionRest> ::= <AssignmentOp> <CompositeExpression> | e

<AssignmentOp> ::= = | += | -=

<CompositeExpression> ::= <BasicExpression> <CompositeExpressionRest>
<CompositeExpressionRest> ::= <BinaryOp> <BasicExpression> <CompositeExpressionRest> | e

<BinaryOp> ::= || | && | == | != | < | > | <= | >= | + | - | * | / | %

<BasicExpression> ::= <UnaryOp> <Operand> | <Operand>

<UnaryOp> ::= + | - | !

<Operand> ::= <Literal>
<Operand> ::= <Access>

<Literal> ::= <PrimitiveLiteral> | <ObjectLiteral>

<PrimitiveLiteral> ::= trueLiteral | falseLiteral | intLiteral | charLiteral
<ObjectLiteral> ::= null | stringLiteral

<Access> ::= <Primary> <ChainedOptional>

<Primary> ::= <ThisAccess>
<Primary> ::= <IdMetVarAccess> /* VarAccess and MethodAccess */
<Primary> ::= <ConstructorAccess>
<Primary> ::= <StaticMethodAccess>
<Primary> ::= <ParenthesizedExpression>

<ThisAccess> ::= this
<IdMetVarAccess> ::= idMetVar <IdMetVarAccessRest>
<IdMetVarAccessRest> ::= <ActualArgs> | e
<ConstructorAccess> ::= new idClass <ActualArgs>
<StaticMethodAccess> ::= idClass . idMetVar <ActualArgs>
<ParenthesizedExpression> ::= ( <Expression> )

<ActualArgs> ::= ( <ExpressionListOptional> )

<ExpressionListOptional> ::= <ExpressionList> | e
<ExpressionList> ::= <Expression> <ExpressionListRest>
<ExpressionListRest> ::= , <ExpressionList> | e

<ChainedOptional> ::= <ChainedIdMetVar> | e
<ChainedIdMetVar> ::= . idMetVar <ChainedIdMetVarRest>
<ChainedIdMetVarRest> ::= <ChainedOptional> | <ActualArgs> <ChainedOptional>
