%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This file is the specification of the LL(1) context-free-grammar of the
language syntax. To be LL(1) any production must have no left recursion and
must be left factored. 

The grammar follows the extended-BNF notation where:
terminal    is a terminal symbol
<Class>     is a non-terminal symbol, with the first letter in uppercase
e           is the empty string
<X>::=a     is a production, where a is a sequence of terminals and non-terminals
<X>::=a|b   is an abbreviation of <X>::=a and <X>::=b
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

--------------------------------------------------------------------------------
1. Classes, Methods and Attributes
--------------------------------------------------------------------------------

<Start> ::= <ClassList> $
<ClassList> ::= <Class> <ClassList> | e
<Class> ::= <AbstractOptional> class <ClassType> <InheritanceOptional> { <MemberList> }
<InheritanceOptional> ::= extends <ClassType> | e

<MemberList> ::= <VisibilityOptional> <Member> <MemberList> | e
<Member> ::= idClass <MaybeConstructor>
<Member> ::= abstract <MemberType> idMetVar <FormalArgs> ;
<Member> ::= static <MemberType> idMetVar <MemberRest>
<Member> ::= void idMetVar <FormalArgs> <Block>
<Member> ::= <PrimitiveType> idMetVar <MemberRest>

<MaybeConstructor> ::= <FormalArgs> <Block> | <GenericTypeOptional> idMetVar <MemberRest>
<MemberRest> ::= ; | <AssignmentOp> <CompositeExpression> ; | <FormalArgs> <Block>

<StaticOptional> ::= static | e
<AbstractOptional> ::= abstract | e
<VisibilityOptional> ::= public | private | e

<MemberType> ::= <Type> | void
<Type> ::= <PrimitiveType> | <ClassType>
<PrimitiveType> ::= boolean | char | int | float
<ClassType> ::= idClass <GenericTypeOptional>

<GenericTypeOptional> ::= < <GenericTypeList> > | e
<GenericTypeList> ::= <ClassType> <GenericTypeListRest>
<GenericTypeListRest> ::= , <GenericTypeList> | e

<FormalArgs> ::= ( <FormalArgsListOptional> )
<FormalArgsListOptional> ::= <FormalArgsList> | e
<FormalArgsList> ::= <FormalArg> <FormalArgsListRest>
<FormalArgsListRest> ::= , <FormalArgsList> | e
<FormalArg> ::= <Type> idMetVar

--------------------------------------------------------------------------------
2. Statements and Blocks
--------------------------------------------------------------------------------

<Block> ::= { <StatementList> }
<StatementList> ::= <Statement> <StatementList> | e
<StatementOptional> ::= <Statement> | e

<Statement> ::= ;
<Statement> ::= <Expression> ; /* Assignment or Call */
<Statement> ::= <LocalVar> ;
<Statement> ::= <Return> ;
<Statement> ::= <Break> ;
<Statement> ::= <If>
<Statement> ::= <For>
<Statement> ::= <While>
<Statement> ::= <Switch>
<Statement> ::= <Block>

<LocalVar> ::= var idMetVar <AssignmentOp> <CompositeExpression>
<LocalVar> ::= <Type> <IdMetVarList> <AssignmentOp> <CompositeExpression>
<IdMetVarList> ::= idMetVar <IdMetVarListRest>
<IdMetVarListRest> ::= , <IdMetVarList> | e

<Return> ::= return <ExpressionOptional>
<Break> ::= break

<If> ::= if ( <Expression> ) <Statement> <IfRest>
<IfRest> ::= else <Statement> | e

<For> ::= for ( <ForRest>
<ForRest> ::= <VarOptional> idMetVar = <CompositeExpression> ; <ExpressionOptional> ; <ExpressionOptional> ) <Statement>
<ForRest> ::= <ClassType> idMetVar : <Access> ) <Statement>
<ForRest> ::= ; <ExpressionOptional> ; <ExpressionOptional> ) <Statement>

<VarOptional> ::= var | e

<While> ::= while ( <Expression> ) <Statement>

<Switch> ::= switch ( <Expression> ) { <SwitchStatementList> }
<SwitchStatementList> ::= <SwitchStatement> <SwitchStatementList> | e
<SwitchStatement> ::= case <PrimitiveLiteral> : <StatementOptional>
<SwitchStatement> ::= default : <Statement>

--------------------------------------------------------------------------------
3. Expressions
--------------------------------------------------------------------------------

<ExpressionOptional> ::= <Expression> | e
<Expression> ::= <CompositeExpression> <ExpressionRest>
<ExpressionRest> ::= <AssignmentOp> <CompositeExpression> | e

<AssignmentOp> ::= = | += | -=

<CompositeExpression> ::= <BasicExpression> <CompositeExpressionRest>
<CompositeExpressionRest> ::= <BinaryOp> <BasicExpression> <CompositeExpressionRest> | e

<BinaryOp> ::= || | && | == | != | < | > | <= | >= | + | - | * | / | %

<BasicExpression> ::= <UnaryOp> <Operand> | <Operand>

<UnaryOp> ::= + | - | !

<Operand> ::= <Literal>
<Operand> ::= <Access>

<Literal> ::= <PrimitiveLiteral> | <ObjectLiteral>

<PrimitiveLiteral> ::= trueLiteral | falseLiteral | intLiteral | floatLiteral | charLiteral
<ObjectLiteral> ::= null | stringLiteral

<Access> ::= <Primary> <ChainedOptional>

<Primary> ::= <ThisAccess>
<Primary> ::= <IdMetVarAccess> /* VarAccess and MethodAccess */
<Primary> ::= <ConstructorAccess>
<Primary> ::= <StaticMethodAccess>
<Primary> ::= <ParenthesizedExpression>

<ThisAccess> ::= this
<IdMetVarAccess> ::= idMetVar <IdMetVarAccessRest>
<IdMetVarAccessRest> ::= <ActualArgs> | e
<ConstructorAccess> ::= new idClass <GenericTypeOptionalEmpty> <ActualArgs>
<StaticMethodAccess> ::= idClass . idMetVar <ActualArgs>
<ParenthesizedExpression> ::= ( <Expression> )

<GenericTypeOptionalEmpty> ::= < <GenericListOptional> > | e
<GenericListOptional> ::= <GenericTypeList> | e

<ActualArgs> ::= ( <ExpressionListOptional> )

<ExpressionListOptional> ::= <ExpressionList> | e
<ExpressionList> ::= <Expression> <ExpressionListRest>
<ExpressionListRest> ::= , <ExpressionList> | e

<ChainedOptional> ::= <ChainedIdMetVar> | e
<ChainedIdMetVar> ::= . idMetVar <ChainedIdMetVarRest>
<ChainedIdMetVarRest> ::= <ChainedOptional> | <ActualArgs> <ChainedOptional>
